package picasso2;

import java.awt.Color;
import java.awt.GridLayout;
import java.awt.LayoutManager;

import javax.swing.BorderFactory;
import javax.swing.JButton;
import javax.swing.JPanel;
import javax.swing.JToolBar;

/*PF: JPanel that holds ToolButtons
 * Is placed in Background Panel in PicassoToolBar
 */

public class PicassoButtonPanel extends JPanel implements NewObserver {
	
	public PicassoButtonPanel() {
		//PF: Set bounds
		setBounds(20, 5, 190, 70);
		
		/*PF: Set Layout to GridLayout
		 * 2 rows, 4 columns
		 * with 7 as a horizontal gap
		 * and 10 as a vertical gap
		 */
		setLayout (new GridLayout(2, 4, 7, 10));
		
		addButtons();
	}

	private void addButtons() {
		for (int i = 0; i < 8; i++) {
			JButton new_button = new JButton("" + (i + 1));
			this.add(new_button);
		}
	}
	
	//PF: Sets button panel horizontal
	private void setButtonLayoutHorizontal() {
		setBounds(20, 5, 190, 70);
		setLayout(new GridLayout(2, 4, 7, 10));
	}
	
	//PF: Sets button panel vertical
	private void setButtonLayoutVertical() {
		//PF: Create variables parent_name and parent_width
		String parent_name = getParent().getParent().getParent().getName();
		int parent_width = 0;
		
		/*PF: Check if PicassoToolBar is separated
		 * then set parent_width to appropriate width.
		 * **NOTE** This is done because PicassoToolBar's
		 * minimum width when 
		 */
		if(parent_name != null && parent_name.equals("null.contentPane")) {
			parent_width = 126;
		} else {
			parent_width = 100;
		}
		
		setBounds(((parent_width - 90) / 2), 20, 90, 190);
		setLayout(new GridLayout(4, 2, 5, 7));
	}

	/*PF: When PicassoToolBar's orientation changes,
	 * PicassoButtonPanel's UI is switched to fit
	 * inside of PicassoToolBar
	 */
	@Override
	public void update(Object obj) {
		
		switch((int) obj) {
		
		case JToolBar.VERTICAL:
			setButtonLayoutVertical();
			break;
			
		case JToolBar.HORIZONTAL:
			setButtonLayoutHorizontal();
			break;
		}
		
		/*PF: Need to call revalidate
		 * since Layout Manager is changing
		 */
		revalidate();
	}
	
}
